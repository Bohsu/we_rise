## MySQL 注意事项

安装服务端及客户端，以及基本操作网上资料很多，这里主要说下 Rails 项目涉及到的点

### 一. 数据库命令规范

- 所有数据库对象名称必须使用小写字母并用下划线分割
- 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）
- 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符
- 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）

### 二 数据库基本设计规范

**1. 所有表必须使用Innodb存储引擎**

没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好

**2、数据库和表的字符集统一使用UTF8**

兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效

**3、所有表和字段都需要添加注释**

使用comment从句添加表和列的备注 从一开始就进行数据字典的维护

**4、尽量控制单表数据量的大小，建议控制在500万以内**

500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题

可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小

### 三. 数据库字段设计规范

**1. 优先选择符合存储需要的最小的数据类型**

- 原因: 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的IO次数也就越多， 索引的性能也就越差 

- 方法:  将字符串转换成数字类型存储

**2. 避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据**

- 建议把BLOB或是TEXT列分离到单独的扩展表, 对于这种数据，Mysql还是要进行二次查询，会使sql性能变得很差

**3. 尽可能把所有列定义为NOT NULL**

   原因：

- 索引NULL列需要额外的空间来保存，所以要占用更多的空间；
- 进行比较和计算时要对NULL值做特别的处理

**4. 同财务相关的金额类数据必须使用decimal类型**

- 非精准浮点：float,double
- 精准浮点：decimal

Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。

### 四. 索引设计规范

**1. 限制每张表上的索引数量，建议单张表索引不超过5个**

索引并不是越多越好！索引可以提高效率同样可以降低效率。

**2. 每个Innodb表必须有个主键**

Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。

### 五. 常见索引列建议

- 出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列
- 包含在ORDER BY、GROUP BY、DISTINCT中的字段

并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好

- 多表join的关联列

### 六. 数据库SQL开发规范

**1. 避免数据类型的隐式转换**

隐式转换会导致索引失效。如：select name,phone from customer where id = '111'

**2.充分利用表上已经存在的索引**

- 避免使用双%号的查询条件。

如a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）

- 一个SQL只能利用到复合索引中的一列进行范围查询

如：有 a,b,c列的联合索引，在查询条件中有a列的范围查询，则在b,c列上的索引将不会被用到，在定义联合索引时，如果a列要用到范围查找的话，就要把a列放到联合索引的右侧。

- 使用left join或 not exists来优化not in操作

因为not in 也通常会使用索引失效。

**3. 禁止使用SELECT \* 必须使用SELECT <字段列表> 查询**

原因：

- 消耗更多的CPU和IO以网络带宽资源
- 无法使用覆盖索引
- 可减少表结构变更带来的影响

**4. 避免使用子查询，可以把子查询优化为join操作**

通常子查询在in子句中，且子查询中为简单SQL(不包含union、group by、order by、limit从句)时，才可以把子查询转化为关联查询进行优化。

**5. 避免使用JOIN关联太多的表**

如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。 

同时对于关联操作来说，会产生临时表操作，影响查询效率Mysql最多允许关联61个表，建议不超过5个。

**6. 对应同一列进行or判断时，使用in代替or**

in的值不要超过500个in操作可以更有效的利用索引，or大多数情况下很少能利用到索引。

**7. WHERE从句中禁止对列进行函数转换和计算**

对列进行函数转换或计算时会导致无法使用索引。

- 不推荐：

where date(create_time)='20190101'

- 推荐：

where create_time >= '20190101' and create_time < '20190102'







